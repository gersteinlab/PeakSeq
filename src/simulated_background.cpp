#include <stdio.h>
#include <stdlib.h>
#include "simulated_background.h"
#include "enrichment_profile.h"
#include "mapped_read_tools.h"
#include "rng.h"
#include "seed_manager.h"
#include <math.h>
#include "chip_seq_chr_data.h"
#include <algorithm>

//int n_rand_gens = 0;
//FILE* f_rand = NULL;

bool __DUMP_SIMULATION_MESSAGES__ = false;

int RandomInteger( const int low, const int high )
{
	int k;
	double d;

	int cur_rand_i_nuc = rand();
	//fprintf(f_rand, "%d (%d-%d)\n", cur_rand_i_nuc, low, high);

	// This line normalizes the randomly-generated value to a double in the
	// interval [0,1).
	d = (double) cur_rand_i_nuc / ((double) RAND_MAX + 1);
	// This line scales the decimal number to a number in the desired range
	// size and truncates it to an integral value.
	k = (int) (d * (high - low + 1));
	// This line adds the lower bound of the range to the value and returns
	// the randomly generated value.

	//n_rand_gens++;

	return (low + k);
}

// Generate number of sorted integers.
int n_rand_reps[1000 * 1000 + 10];

void load_sorted_random_integers(int n_integers, vector<int>* rand_ints, vector<int>* rand_offset_ints, int low, int high)
{
	//printf("Generating %d sorted random integers.\n", n_integers);
	//int* n_rand_reps = new int[high - low + 5];
	//memset(n_rand_reps, 0, (high-low+5) * sizeof(int));

	int v_min = 1000000;
	int v_max = 0;
	for(int i = 0; i < n_integers; i++)
	{
		int cur_rand = RandomInteger(low, high);
		if(v_min > cur_rand)
			v_min = cur_rand;

		if(v_max < cur_rand)
			v_max = cur_rand;

		n_rand_reps[cur_rand - low]++; // Increment the number of times this alue is generated.
	}

	// Go over all the vals array in order and add the values that are set to true to rand_ints.
	for(int cur_cand = v_min; cur_cand <= v_max; cur_cand++)
	{
		// Was this value generated by the random number generator?
		for(int i = 0; i < n_rand_reps[cur_cand - low]; i++)
		{
			rand_ints->push_back(cur_cand);
			rand_offset_ints->push_back(cur_cand + 200);
		} // i loop.

		// Reset the value for future use.
		n_rand_reps[cur_cand - low] = 0;
	}

	//delete[] n_rand_reps;
}

// Returns the thresholds per window for the chromosome.
double* simulate(t_chip_seq_chr_data* cur_chr_data,
                int** n_peaks_per_thresh_per_window,
                int n_iterations,
                double target_fdr,
                int enrichment_mapped_fragment_length,
                int min_gap_per_bw_peaks,
                int min_thresh,
                int max_thresh)
{
	//fprintf(stderr, "Simulating!\n");
	//getc(stdin);
	
	//f_rand = open_f("rands.txt", "w");
	// Initialize random number generator.
	//srand(0);

	// Following initialization is necessary when above function is used to generate sorted random numbers.
	//memset(n_rand_reps, 0, 1000*1000* sizeof(int));

if(__DUMP_SIMULATION_MESSAGES__)
{
	fprintf(stderr, "Simulating segmented random fragment selection for thresholds %d,..., %d\n", min_thresh, max_thresh);
}

	int n_wins = cur_chr_data->n_meg_wins();

    t_rng* simul_rng = new t_rng(t_seed_manager::seed_me());
        
	double* thresholds_per_win = new double[n_wins+2];
	for(int i_win = 0; i_win <= n_wins; i_win++)
	{
		//thresholds_per_win[i_win] = max_thresh; // Ensure that no peaks are selected at the initialization, this automatically handles the windows for which there is no data.
		thresholds_per_win[i_win] = 0;
	}

	// Count the number of reads per each window: The count for each window is the number of reads whose base (with respect to forward strand)
	// is in the window.
	int* n_reads_per_window = get_n_reads_per_window(cur_chr_data->n_meg_wins(), cur_chr_data->chip_seq_fragments);

if(__DUMP_SIMULATION_MESSAGES__)
{
	fprintf(stderr, "Counted reads per window.\n");
}

	int* cur_sim_fps = new int[max_thresh - min_thresh + 1];
	double* avg_sim_fps = new double[max_thresh - min_thresh + 1];

	vector<int>* frag_begs = new vector<int>();
	vector<int>* frag_ends = new vector<int>();
	t_enrichment_profile* cur_simul_enrichment_profile = new t_enrichment_profile();

if(__DUMP_SIMULATION_MESSAGES__)
{
	fprintf(stderr, "Generated simul enrichment profile (%d windows)\n", n_wins);
}

	// Go over all the windows: Note that there may be an extra short window at the end, must include that one too.
	for(int i_win = 0; i_win < n_wins; i_win++)
	{
		// Determine the maximum nucleotide count for this segment:
		int max_i_nuc = (i_win + 1) * MEG_BASE-1;
		//set_cur_segment_max_i_nuc(cur_chr, i_win, max_i_nuc);
		int min_i_nuc = i_win * MEG_BASE;

if(__DUMP_SIMULATION_MESSAGES__)
{
		fprintf(stderr, "i_win = %d (%d - %d), %d uniquely mappable nucs, %d reads\n", i_win, min_i_nuc, max_i_nuc, cur_chr_data->n_uniquely_mappable_nucs_per_meg_win->at(i_win), n_reads_per_window[i_win]);
}

		if(n_reads_per_window[i_win] == 0)
		{
if(__DUMP_SIMULATION_MESSAGES__)
{
			fprintf(stderr, "There are no mapped reads in window %d\n", i_win);
}
			//getc(stdin);
		}

		if(cur_chr_data->n_uniquely_mappable_nucs_per_meg_win->at(i_win) == 0)
		{
if(__DUMP_SIMULATION_MESSAGES__)
{
			fprintf(stderr, "There are no uniquely mappable nucleotides in window %d\n", i_win);
}
			//getc(stdin);
		}

		for(int thresh = min_thresh; thresh <= max_thresh; thresh++)
		{
			avg_sim_fps[thresh - min_thresh] = 0.0f;
		} // i_th

		// For each threshold: Note that the threshold limits depend on the maximum and minimum of the enrichment profiles.
		// Make sure that there are mapped reads in this window, and that there are uniquely mappable nucleotides in the window.
		//int n_pred_fps = 0;
		for(int i_sim = 0;
			i_sim < n_iterations && 
			n_reads_per_window[i_win] > 0; 
			i_sim++)
		{
/*
            		FILE* f_rand = open_f("rands.txt", "a");
		            fprintf(f_rand, "i_sim: %d\n", i_sim);
		            fclose(f_rand);
*/
			// Generate N_reads many reads in this segments, store them in a t_enrichment_profile object.
			//vector<t_mapped_fragment*>* simulated_fragments = new vector<t_mapped_fragment*>();
			//t_mapped_fragment** simulated_fragments = new t_mapped_fragment*[n_reads_per_window[i_win] + 3];

			//fprintf(stderr, "Generating random fragment list.\n");
			//`fprintf(f_rand, "i_win: %d\n", i_win);

			frag_begs->clear();
			frag_ends->clear();

			// Load sorted random integers to the begin's.
			int cur_segment_base_i_length = cur_chr_data->n_uniquely_mappable_nucs_per_meg_win->at(i_win);
			//load_sorted_random_integers(n_reads_per_window[i_win], frag_begs, frag_ends, 0, cur_segment_base_i_length);

			// Add the values to ends.
			for(int i_read = 0; i_read < n_reads_per_window[i_win]; i_read++)
			{
				//int cur_rand_i_nuc = (int)(floor(simul_rng->random_double_ran3() * cur_segment_base_i_length));
				int cur_rand_i_nuc = RandomInteger( 0, cur_segment_base_i_length);

				frag_begs->push_back(cur_rand_i_nuc);
				frag_ends->push_back(cur_rand_i_nuc + enrichment_mapped_fragment_length);

				// Add the fragment ends to the profile.
				//cur_simul_enrichment_profile->add_fragment_ends(cur_rand_i_nuc, enrichment_mapped_fragment_length);

			} // i_read loop.

			//fprintf(stderr, "Generated %d random begins and %d random ends.\n", frag_begs->size(), frag_ends->size());
			//getc(stdin);
	
			// Sort the ends and begins.
			sort(frag_begs->begin(), frag_begs->end());
			sort(frag_ends->begin(), frag_ends->end());

			//fprintf(stderr, "Going to count peaks per random fragments.\n");
			//getc(stdin);

			cur_simul_enrichment_profile->count_peaks_per_frags(cur_sim_fps, frag_begs, frag_ends, min_thresh, max_thresh, min_gap_per_bw_peaks);

			// Sort the fragment ends manually and the profile is ready to be processed.
			//sort(cur_simul_enrichment_profile->frag_ends->begin(), cur_simul_enrichment_profile->frag_ends->end(), sort_ends);

/*
			FILE* f_rand_frags = open_f("rand_frags.txt", "w");
			for(int i_frag = 0; i_frag < simulated_fragments->size(); i_frag++)
			{
				fprintf(f_rand_frags, "%d\n", simulated_fragments->at(i_frag)->base_index);
			} // i_frag.
			fclose(f_rand_frags);
*/
			//getc(stdin);


				//cur_simul_enrichment_profile->count_peaks(cur_sim_fps, min_thresh, max_thresh, min_gap_per_bw_peaks, 0, cur_chr_data->n_uniquely_mappable_nucs_per_meg_win->at(i_win));
		
				//fprintf(stderr, "Counted peaks.\n");


                        for(int i_thresh = min_thresh;
                                i_thresh <= max_thresh;
                                i_thresh++)
                        {
                                //fprintf(stderr, "thresh %d: %d\n", i_thresh,  cur_sim_fps[i_thresh - min_thresh]);
				avg_sim_fps[i_thresh - min_thresh] += (double)cur_sim_fps[i_thresh - min_thresh] / n_iterations; // Update the average estimated false discovery ratio.
                        }
			//getc(stdin);

			//delete_fragments(simulated_fragments);
			//delete(cur_simul_enrichment_profile);
                } // sim loop.

		if(cur_chr_data->n_uniquely_mappable_nucs_per_meg_win->at(i_win) > 0)
		{
			// Determine the thresholds for the current window: 
			// Find te threshold for which the FDR of simulation and ChIP-Seq data falls below the maximum and the peak counts for the simulated
			// data is decreasing.
	
			for(int _thresh = min_thresh; _thresh < max_thresh; _thresh++)
			{
					//printf("%d: %lf (%d)\n", _thresh, avg_sim_fps[_thresh - min_thresh], n_peaks_per_thresh_per_window[_thresh - min_thresh][i_win]);
			} // thresh loop.


			// Following is a clone of the procedure utilized in PeakSeq for choosing the threshold.
			int thresh = min_thresh;

			// If the FDR for first threshold is LEQ to target_fdr and following FDR is decreasing, return this threshold.
//			if(((long double)avg_sim_fps[thresh-min_thresh] / n_chip_seq_peaks[thresh - min_thresh] <= target_fdr) &&
//				(avg_sim_fps[thresh-min_thresh] > avg_sim_fps[thresh-min_thresh+1]))

      		if(((long double)avg_sim_fps[thresh-min_thresh] / n_peaks_per_thresh_per_window[thresh - min_thresh][i_win] <= target_fdr) &&
              		(avg_sim_fps[thresh-min_thresh] > avg_sim_fps[thresh-min_thresh+1]))
			{
				thresholds_per_win[i_win] = thresh;
			}
			else
			{
				// Find the first threshold for which average false positive count decreases.
				thresh = min_thresh + 1;
				while(thresh <= max_thresh && 
					avg_sim_fps[thresh-min_thresh-1] <= avg_sim_fps[thresh-min_thresh])
				{
					thresh++;
				}
				//printf("Out @ %d (%lf)\n", thresh, target_fdr);
	
				for(; thresh <= max_thresh; thresh++)
				{
					// If there are no peaks in the ChIP-Seq data for this threshold, return this threshold.
					if(n_peaks_per_thresh_per_window[thresh - min_thresh][i_win] == 0)
					{
						//printf("0 peaks in ChIP-Seq data for threshold %d (%d, %d)\n", thresh, min_height, max_height );
						thresholds_per_win[i_win] = thresh;
		
						//cur_chr_data->chip_seq_enr_prof->dump_profile("chip_profile.txt", min_i_nuc, max_i_nuc);
		
						//printf("Avg. simulated fp's:\n");
						for(int thresh = min_thresh; thresh <= max_thresh; thresh++)
						{
							//if(avg_sim_fps[thresh - min_thresh] > 0.0f)
							if(n_peaks_per_thresh_per_window[thresh - min_thresh][i_win] > 0)
							{
								//printf("%d: %.3f (%.3f) (%d)\n ", thresh, avg_sim_fps[thresh - min_thresh], avg_sim_fps[thresh-min_thresh] / n_peaks_per_thresh_per_window[thresh - min_thresh][i_win], n_peaks_per_thresh_per_window[thresh - min_thresh][i_win]);
							}
						}
						//printf("\n");
		
						break;
					}
					// If the peaks at this 
					else 
					{
						long double target_fdr_ld = target_fdr;
						//long double cur_fdr = (long double)avg_sim_fps[thresh-min_thresh] / n_chip_seq_peaks[thresh-min_thresh];
						long double cur_fdr = (long double)avg_sim_fps[thresh-min_thresh] / n_peaks_per_thresh_per_window[thresh - min_thresh][i_win];
						//fprintf(stderr, "%d: cur_fdr: %lf, %lf\n", thresh, (double)cur_fdr, target_fdr);

						if(cur_fdr <= target_fdr_ld)
						{
/*
							if(cur_fdr == target_fdr)
							{
								printf("i_win: %d, cur_fdr = target_fdr\n", i_win);
								getc(stdin);
							}
*/
			
							//printf("Found at %.5f, %d, %.15f\n", avg_sim_fps[thresh-min_thresh], n_chip_seq_peaks[thresh-min_thresh], avg_sim_fps[thresh-min_thresh] / n_chip_seq_peaks[thresh-min_thresh]);
							// If the counts for simulated fps are decreasing, this is the threshold.
							thresholds_per_win[i_win] = thresh;
							break;
						} // target_fdr check.
					}
				} // thresh loop.
			}
	
            //fprintf(stderr, "Window %d: %lf (%lf/%d)\n", i_win, thresholds_per_win[i_win], avg_sim_fps[(int)thresholds_per_win[i_win]-min_thresh], n_chip_seq_peaks[(int)thresholds_per_win[i_win]-min_thresh]);
			if(thresholds_per_win[i_win] > 0)
			{
if(__DUMP_SIMULATION_MESSAGES__)
{
				fprintf(stderr, "Window %d: %lf (%lf/%d)\n", i_win, thresholds_per_win[i_win], avg_sim_fps[(int)thresholds_per_win[i_win]-min_thresh], n_peaks_per_thresh_per_window[thresh - min_thresh][i_win]);
}
			}
		} // Check if there are uniquely mappable nucleotides in this window, if not it is not necessary to process the window.
   } // i_win loop.

        delete(frag_begs);
        delete(frag_ends);
        delete(cur_simul_enrichment_profile);

/*
	char threshes_fp[1000];
	sprintf(threshes_fp,"%s_threshes.txt" , cur_chr_data->chr_id);
	FILE* f_threshes = open_f(threshes_fp, "w");
	for(int i_win = 0; i_win < n_wins; i_win++)
	{
		fprintf(f_threshes, "%d %lf\n", i_win, thresholds_per_win[i_win]);
	} // i_Win loop.
	fclose(f_threshes);
*/

	delete [] cur_sim_fps;
	delete [] avg_sim_fps;

	delete [] n_reads_per_window;

	// Process the remaining part of the chromosome.
	delete(simul_rng);

	// Return the list of threshold arrays.
	return(thresholds_per_win);
}



